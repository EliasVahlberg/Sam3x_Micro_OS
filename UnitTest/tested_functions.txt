/**
* @file
*     tested_functions.txt
* @authors 
*     Elias Vahlberg
*     Hamed Haghjo
* \brief 
*     ...
*/

communication.c
    msg*        mailbox_dequeue(mailbox *mBox);
                Check - Trying to dequeue from non existing mailbox
                Check - Trying to dequeue from existing mailbox with nothing in it
                Check - Dequeuing in right order
                Check - If message was really dequeued, and size of mailbox decreases
                Check - If message was really freed
                Check - Returned msg's data and if it return NULLPOINTER
                
    exception   mailbox_enqueue(mailbox *mBox, msg *mes);
                Check - Memory full, trying to enqueue?
                Check - Trying to enqueue to a non existing mailbox
                Check - Mes exists?
                Check - Enqueues in the right order?
                Check - Message really enqueued? Check the corresponding data of mes
                Check - Enqueue to allocation failure
                Check - Return types
                
    mailbox*    create_mailbox(uint nMessages, uint nDataSize)
                Check - Trying to create a mailbox when memory is full (Return type)

    exception   append_msg(msg *mes, mailbox *mBox, void *pData, int status, int wait)
                Check - 
                Check - 
                Check - 
    exception   remove_mailbox(mailbox *mBox)
    exception   send_wait(mailbox *mBox, void *pData)
    exception   receive_wait(mailbox *mBox, void *pData)
    exception   send_no_wait(mailbox *mBox, void *pData)
    exception   receive_no_wait(mailbox *mBox, void *pData)
    exception   no_messages(mailbox *mBox)

    #*#*# exception force_remove_mailbox(mailbox *mBox)
    
common_functions.c
    static int  __ISR_ON(void)
    static int  __ISR_OFF(void)
    uint        min(uint a, uint b)
    

kernel_init.c
    exception   init_kernel(void);
    list*       create_task_list(void);
    void        idle();    
    
memory_manager.c
    void*       mem_alloc(size_t size)
    void        mem_free(void *mem)
    exception   mem_copy(char* src, char* dest, uint size)
    void        update_meminfo()
    int         dynamic_mem_adress(void *ptr)

kernel.c
    void        terminate(void);
    void        run(void);

tasks.c
    exception   add_task_2_list(list *l, TCB *task);
            #BEFORE TEST Create 3 Lists with 0,1,3 elements  
            Add to empty list
                check if there
            Add to list with 1 element
                check if there
                check position
            Add to list with multiple elements
                check if there
                check position
            

    exception   move_listobj(list *src, list *dest, listobj* o1);
            #BEFORE TEST Create 6 Lists with {0,0},{0,1},{1,0},{1,1},{3,1},{1,3},{3,3} elements  
            Move using all the lists above 
                check for NULLPOINTER,
                check for FAIL
                check that the element is in dest
                check that the element is not in src
            Try to move object not in src list 
                check for FAIL
            Try to move object in dest
                check for FAIL
            Move 100 time back and forth 
            check for FAIL
            check memory

    static int  compare_listobj(listobj *o1, listobj *o2);
            #BEFORE TEST create 4 list objects: 1: {NULL},2: { DL = 1, nTCnt = 0},3: { DL = 2, nTCnt = 0},4: { DL = 3 nTCnt = 1},5: { DL = 3 nTCnt = 2} 
            compare: (1,2)
                Assert return = -1
            compare: (1,3)
                Assert return = -1
            compare: (1,4)
                Assert return = -1
            compare: (1,5)
                Assert return = -1
            compare: (2,3)
                Assert return = 1
            compare: (2,4)
                Assert return = 1
            compare: (2,5)
                Assert return = 1
            compare: (3,4)
                Assert return = 0
            compare: (3,5)
                Assert return = 1
            compare: (4,5)
                Assert return = 1
                
    listobj*    create_listobj(TCB *task,uint nTCnt);
    exception   create_task(void (*tbody)(), uint dl)
    exception   remove_last(list *list);
    exception   push(list *l, TCB *task,uint nTCnt);
    exception   pop(list* list);
    exception   find_task(list* l, TCB *task);

    #*#*exception   remove_listobj(list *l, listobj *o1);
    #*#*exception   remove_task(list *l, TCB *task);

timing.c
    void        set_ticks(uint ticks);
    uint        ticks(void);
    uint        deadline(void);
    int         deadline_reached(TCB* task);
    void        set_deadline(uint deadline);
    exception   wait(uint nTicks);
    extern void TimerInt(void);